<#@ template language="C#" #>
<#@ output extension=".gen.cs" #>
<#
// UnitTests.tt
//
// Author:
//     Jon Hanna <jon@hackcraft.net>
//
// © 2014 Jon Hanna
//
// Licensed under the EUPL, Version 1.1 only (the “Licence”).
// You may not use, modify or distribute this work except in compliance with the Licence.
// You may obtain a copy of the Licence at:
// <http://joinup.ec.europa.eu/software/page/eupl/licence-eupl>
// A copy is also distributed with this source code.
// Unless required by applicable law or agreed to in writing, software distributed under the
// Licence is distributed on an “AS IS” basis, without warranties or conditions of any kind.
#>
// UnitTests.gen.cs
//
// Generated File. DO NOT EDIT THIS FILE. Edit Overloads.tt to change the produced file.
//
// Licensed under the EUPL, Version 1.1 only (the “Licence”).
// You may not use, modify or distribute this work except in compliance with the Licence.
// You may obtain a copy of the Licence at:
// <http://joinup.ec.europa.eu/software/page/eupl/licence-eupl>
// A copy is also distributed with this source code.
// Unless required by applicable law or agreed to in writing, software distributed under the
// Licence is distributed on an “AS IS” basis, without warranties or conditions of any kind.


using System;
using Mnemosyne;
using NUnit.Framework;

namespace Mnemosyne.Tests
{
    [TestFixture]
    public unsafe class MnemosyneTests
    {
        private const int SourceLen = 1024;
        private const int SourceByteLen = SourceLen * 2;
        private static string Source = new string('ሴ', SourceLen);// U+1234, meaning each byte is set, and easily determined.
        private static string ByteRepString = new string('ሒ', SourceLen); // U+1212, so each byte is set the same.
        private static string AllNullString = new string('\0', SourceLen); // each byte is zero.
<#
foreach(string type in new[]{"IntPtr", "UIntPtr", "void*"})
{
    string methodLabel = type.Replace("void*", "VoidPointer");
#>
        [Test]
        public void SimpleCopy<#=methodLabel#>()
        {
            for(int len = 0; len != SourceLen; ++len)
            {
                char[] output = new char[len];
                fixed(char* source = Source)
                {
                    fixed(char* dest = output)
                        Memory.CopyAligned((<#=type#>)dest, (<#=type#>)source, 2 * len);
                    Assert.AreEqual(Source.Substring(0, len), new string(output));
                    output = new char[len];
                    fixed(char* dest = output)
                        Memory.Copy((<#=type#>)dest, (<#=type#>)source, 2 * len);
                    Assert.AreEqual(Source.Substring(0, len), new string(output));
                }
            }
        }
        [Test]
        public void SimpleSet<#=methodLabel#>()
        {
            char[] output = new char[SourceLen];
            fixed(char* dest = output)
                Memory.SetAligned((<#=type#>)dest, 0x12, SourceByteLen);
            Assert.AreEqual(ByteRepString, new string(output));
            fixed(char* dest = output)
                Memory.ZeroAligned((<#=type#>)dest, SourceByteLen);
            Assert.AreEqual(AllNullString, new string(output));
            fixed(char* dest = output)
                Memory.Set((<#=type#>)dest, 0x12, SourceByteLen);
            Assert.AreEqual(ByteRepString, new string(output));
            fixed(char* dest = output)
                Memory.Zero((<#=type#>)dest, SourceByteLen);
            Assert.AreEqual(AllNullString, new string(output));
        }
<#}#>
    }
}
