<#@ template language="C#" #>
<#@ output extension=".il" #>
<#
// CopyOverloads.tt
//
// Author:
//     Jon Hanna <jon@hackcraft.net>
//
// © 2014–2017 Jon Hanna
//
// Licensed under the MIT license. See the LICENSE file in the repository root for more details.
#>
// Overloads.il
//
// Generated File. DO NOT EDIT THIS FILE. Edit Overloads.tt to change the produced file.
//
// Licensed under the MIT license. See the LICENSE file in the repository root for more details.

.assembly extern mscorlib
{
    .publickeytoken = (
        b7 7a 5c 56 19 34 e0 89
    )
}

.namespace Mnemosyne
{
    .class public auto ansi abstract sealed beforefieldinit Memory extends [mscorlib]System.Object
    {
<#
// This adds some overloads for the methods in other files, but which use native int (seen by most .NET/Mono code as
// IntPtr) and native uint (UIntPtr), instead of void*. All of them are implemented by type-punning through jmping into
// the equivalent method that uses void*, because that’s a simple way to do so.
foreach(string type in new[]{"native int", "native uint"})
foreach(string lenType in new[]{"int32", "uint32"})
{
    // If the type we’re writing overloads for is native int, and if the other arguments are all of CLS-Compliant types
    // then the method will be CLS-Compliant, and we’ve marked this assembly as such because while most of the methods
    // in fact aren’t, it’s good to be CLS-Compliant when you can. Therefore, we add the attribute to mark this as
    // not CLS-Compliant if necessary, but not otherwise.     
    string clsCom = type  == "native int" && lenType == "int32"
        ? ""
        : ".custom instance void [mscorlib]System.CLSCompliantAttribute::.ctor(bool) = (01 00 00 00 00)";

#>
        .method public hidebysig static void CopyAligned(<#=type#> dest, <#=type#> source, <#=lenType#> length)
        {
            .custom instance void [mscorlib]System.Security.SecurityCriticalAttribute::.ctor() = (01 00 00 00)
            <#=clsCom#>
            .maxstack 0
            jmp void Mnemosyne.Memory::CopyAligned(void*, void*, <#=lenType#>)
        }

        .method public hidebysig static void Copy(<#=type#> dest, <#=type#> source, <#=lenType#> length)
        {
            <#=clsCom#>
            .custom instance void [mscorlib]System.Security.SecurityCriticalAttribute::.ctor() = (01 00 00 00)
            .maxstack 0
            jmp void Mnemosyne.Memory::Copy(void*, void*, <#=lenType#>)

        }

        .method public hidebysig static void SetAligned(<#=type#> dest, uint8 'value', <#=lenType#> length)
        {
            .custom instance void [mscorlib]System.Security.SecurityCriticalAttribute::.ctor() = (01 00 00 00)
            <#=clsCom#>
            .maxstack 0
            jmp void Mnemosyne.Memory::SetAligned(void*, uint8, <#=lenType#>)
        }

        .method public hidebysig static void Set(<#=type#> dest, uint8 'value', <#=lenType#> length)
        {
            .custom instance void [mscorlib]System.Security.SecurityCriticalAttribute::.ctor() = (01 00 00 00)
            <#=clsCom#>
            .maxstack 0
            jmp void Mnemosyne.Memory::Set(void*, uint8, <#=lenType#>)
        }

        .method public hidebysig static void ZeroAligned(<#=type#> dest, <#=lenType#> length)
        {
            .custom instance void [mscorlib]System.Security.SecurityCriticalAttribute::.ctor() = (01 00 00 00)
            <#=clsCom#>
            .maxstack 0
            jmp void Mnemosyne.Memory::ZeroAligned(void*, <#=lenType#>)
        }

        .method public hidebysig static void Zero(<#=type#> dest, <#=lenType#> length)
        {
            .custom instance void [mscorlib]System.Security.SecurityCriticalAttribute::.ctor() = (01 00 00 00)
            <#=clsCom#>
            .maxstack 0
            jmp void Mnemosyne.Memory::Zero(void*, <#=lenType#>)

        }
<#}#>
    }
}
