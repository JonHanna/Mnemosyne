<#@ template language="C#" #>
<#@ output extension=".il" #>
<#
// CopyOverloads.tt
//
// Author:
//     Jon Hanna <jon@hackcraft.net>
//
// © 2014 Jon Hanna
//
// Licensed under the EUPL, Version 1.1 only (the “Licence”).
// You may not use, modify or distribute this work except in compliance with the Licence.
// You may obtain a copy of the Licence at:
// <http://joinup.ec.europa.eu/software/page/eupl/licence-eupl>
// A copy is also distributed with this source code.
// Unless required by applicable law or agreed to in writing, software distributed under the
// Licence is distributed on an “AS IS” basis, without warranties or conditions of any kind.
#>
// Overloads.il
//
// Generated File. DO NOT EDIT THIS FILE. Edit Overloads.tt to change the produced file.
//
// Licensed under the EUPL, Version 1.1 only (the “Licence”).
// You may not use, modify or distribute this work except in compliance with the Licence.
// You may obtain a copy of the Licence at:
// <http://joinup.ec.europa.eu/software/page/eupl/licence-eupl>
// A copy is also distributed with this source code.
// Unless required by applicable law or agreed to in writing, software distributed under the
// Licence is distributed on an “AS IS” basis, without warranties or conditions of any kind.

.assembly extern mscorlib { }

.namespace Mnemosyne
{
    .class public auto ansi abstract sealed beforefieldinit Memory extends [mscorlib]System.Object
    {
<#
// This adds some overloads for the methods in other files, but which use native int (seen by most .NET/Mono code as
// IntPtr) and native uint (UIntPtr), instead of void*. All of them are implemented by type-punning through jmping into
// the equivalent method that uses void*, because that’s a simple way to do so.
foreach(string type in new[]{"native int", "native uint"})
{
    // If the type we’re writing overloads for is native int, and if the other arguments are all of CLS-Compliant types
    // then the method will be CLS-Compliant, and we’ve marked this assembly as such because while most of the methods
    // in fact aren’t, it’s good to be CLS-Compliant when you can. Therefore, we add the attribute to mark this as
    // not CLS-Compliant if necessary, but not otherwise.     
    string clsCom = type == "native int"
        ? ""
        : ".custom instance void [mscorlib]System.CLSCompliantAttribute::.ctor(bool) = (01 00 00 00 00)";

#>
        .method public hidebysig static void CopyAligned(<#=type#> dest, <#=type#> source, int32 length)
        {
            .custom instance void [mscorlib]System.Security.SecurityCriticalAttribute::.ctor() = (01 00 00 00)
            <#=clsCom#>
            .maxstack 0
            jmp void Mnemosyne.Memory::CopyAligned(void*, void*, int32)
        }

        .method public hidebysig static void CopyAligned(<#=type#> dest, <#=type#> source, uint32 length)
        {
            .custom instance void [mscorlib]System.Security.SecurityCriticalAttribute::.ctor() = (01 00 00 00)
            .custom instance void [mscorlib]System.CLSCompliantAttribute::.ctor(bool) = (01 00 00 00 00)
            .maxstack 0
            jmp void Mnemosyne.Memory::CopyAligned(void*, void*, uint32)
        }

        .method public hidebysig static void Copy(<#=type#> dest, <#=type#> source, int32 length)
        {
            <#=clsCom#>
            .custom instance void [mscorlib]System.Security.SecurityCriticalAttribute::.ctor() = (01 00 00 00)
            .maxstack 0
            jmp void Mnemosyne.Memory::Copy(void*, void*, int32)

        }

        .method public hidebysig static void Copy(<#=type#> dest, <#=type#> source, uint32 length)
        {
            .custom instance void [mscorlib]System.Security.SecurityCriticalAttribute::.ctor() = (01 00 00 00)
            .custom instance void [mscorlib]System.CLSCompliantAttribute::.ctor(bool) = (01 00 00 00 00)
            .maxstack 0
            jmp void Mnemosyne.Memory::Copy(void*, void*, uint32)
        }

        .method public hidebysig static void SetAligned(<#=type#> dest, uint8 'value', uint32 length)
        {
            .custom instance void [mscorlib]System.Security.SecurityCriticalAttribute::.ctor() = (01 00 00 00)
            .custom instance void [mscorlib]System.CLSCompliantAttribute::.ctor(bool) = (01 00 00 00 00)
            .maxstack 0
            jmp void Mnemosyne.Memory::SetAligned(void*, uint8, uint32)
        }

        .method public hidebysig static void SetAligned(<#=type#> dest, uint8 'value', int32 length)
        {
            .custom instance void [mscorlib]System.Security.SecurityCriticalAttribute::.ctor() = (01 00 00 00)
            <#=clsCom#>
            .maxstack 0
            jmp void Mnemosyne.Memory::SetAligned(void*, uint8, int32)

        OutOfRange:
            ldstr "length"
            newobj instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string)
            throw
        }

        .method public hidebysig static void Set(<#=type#> dest, uint8 'value', int32 length)
        {
            .custom instance void [mscorlib]System.Security.SecurityCriticalAttribute::.ctor() = (01 00 00 00)
            <#=clsCom#>
            .maxstack 0
            jmp void Mnemosyne.Memory::Set(void*, uint8, int32)
        }

        .method public hidebysig static void Set(<#=type#> dest, uint8 'value', uint32 length)
        {
            .custom instance void [mscorlib]System.Security.SecurityCriticalAttribute::.ctor() = (01 00 00 00)
            .custom instance void [mscorlib]System.CLSCompliantAttribute::.ctor(bool) = (01 00 00 00 00)
            jmp void Mnemosyne.Memory::Set(void*, uint8, uint32)
        }
        
        .method public hidebysig static void ZeroAligned(<#=type#> dest, uint32 length)
        {
            .custom instance void [mscorlib]System.Security.SecurityCriticalAttribute::.ctor() = (01 00 00 00)
            .custom instance void [mscorlib]System.CLSCompliantAttribute::.ctor(bool) = (01 00 00 00 00)
            .maxstack 0
            jmp void Mnemosyne.Memory::ZeroAligned(void*, uint32)
        }

        .method public hidebysig static void ZeroAligned(<#=type#> dest, int32 length)
        {
            .custom instance void [mscorlib]System.Security.SecurityCriticalAttribute::.ctor() = (01 00 00 00)
            <#=clsCom#>
            .maxstack 0
            jmp void Mnemosyne.Memory::ZeroAligned(void*, int32)
        }

        .method public hidebysig static void Zero(<#=type#> dest, int32 length)
        {
            .custom instance void [mscorlib]System.Security.SecurityCriticalAttribute::.ctor() = (01 00 00 00)
            <#=clsCom#>
            .maxstack 0
            jmp void Mnemosyne.Memory::Zero(void*, int32)

        }

        .method public hidebysig static void Zero(<#=type#> dest, uint32 length)
        {
            .custom instance void [mscorlib]System.Security.SecurityCriticalAttribute::.ctor() = (01 00 00 00)
            .custom instance void [mscorlib]System.CLSCompliantAttribute::.ctor(bool) = (01 00 00 00 00)
            .maxstack 0
            jmp void Mnemosyne.Memory::Zero(void*, uint32)
        }
<#}#>
    }
}